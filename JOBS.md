# Jobs

## Build up your tech skills: resource dump
* [Developer Roadmaps](https://roadmap.sh/) - I used this to figure out what technologies my mentees and I should learn and what paths we should take.
* [Sakib’s Internship Guide](https://pastebin.com/wq2kc0a2) - I wrote this a while ago for my mentees when they were freshmen/sophomores. Covers a four-point plan to build you up: CTCI, Linux, AppDev, Website.
* [Ubuntu, Git, Python, Flask](https://pastebin.com/xwXsdwHW) - Some links I compiled because people kept asking me where to learn this stuff and how to dual-boot [Ubuntu](https://ubuntu.com).
* [Leetcode](https://leetcode.com) and [CTCI](http://www.crackingthecodinginterview.com) are what I used to get decent at coding interviews. Leetcode has specific problem sets that highlight which questions are common for companies like FB, Google, Amazon, etc. Share an account with your friends.
* [CLRS](https://ms.sapientia.ro/~kasa/Algorithms_3rd.pdf) is the book to study or reference algorithms more advanced than those you learn in basic data structures. It’s often the textbook for Undergraduate Algorithms classes. Interviews won’t typically ask you questions of this kind until you’re a senior.
* Resume/LinkedIn - When you’re a freshman, you won’t have nearly as much 
as experience as upperclassmen or privileged folk who were hand-held in tech earlier in life, and that’s okay. There’s internship programs that specifically [cater to newbies](https://www.wellesley.edu/careereducation/resources/technology-internships-first-years-and-sophomores). But you should still start making your resume and set up your LinkedIn! Your mentors can answer your specific questions on bolding, spacing, active wording, highlighting numbers, etc. Here’s some templates to inspire you: [Popular LaTeX Resume](https://github.com/deedy/Deedy-Resume), [My Google Docs Resume in senior year](https://drive.google.com/file/d/0B2ciTY-dBJClS0loQ2dYRUQzQWc/view), or just Google free resume builders, they just ask you to input your information and they export PDFs for you.


## Companies optimize against false positives, not against false negatives
Hiring you is a big risk. Not because it’s you, but objectively, hiring full-time employees and even interns is extremely expensive. From a company’s perspective, it’s much better to accidentally not-hire a good candidate than it is to hire a bad candidate. That’s why the Tech Interview process is the way it is: asking random data structures and algorithms questions seems unfair and [RNG-based](https://www.urbandictionary.com/define.php?term=RNG) from a candidate’s perspective, but from a company’s perspective, it works pretty well at separating A-players from B- and C-players. The best you can do as a candidate is again, use all the time you have to prepare for all the types of questions they can throw at you. Work with your mentors, and keep a tight calendar to figure out how to balance this with acing all your classes.


## Consider yourself as a portfolio
As a freshman or sophomore, companies don’t really have anything to judge you by besides your GPA. Also, freshman year GPA has the biggest impact on your GPA throughout your years of college, so prioritize academics early on, and consider applying to on-campus jobs or research, like [Open System Solutions](http://oss.rutgers.edu/), [LCSR](https://www.cs.rutgers.edu/lcsr/), [iLab Assistant](https://resources.cs.rutgers.edu/docs/instructional-lab/), ARESTY Research Program (https://aresty.rutgers.edu), etc.


## Hiring pipelines
Say you’re lead hiring manager for Google and you receive millions of applications per year. How would you approach this problem? First, [read this](https://www.wayup.com/guide/community/keep-your-recruiters-straight/). Here’s an overview of what modern intern hiring pipelines usually look like:
* Sourcing: [Read this](https://medium.com/@bkielinski/the-ultimate-guide-to-finding-your-next-technical-hire-for-free-a20a1ba77f03#.k9ds88jb3). Technical sourcers search for talent. It’s easier to discover you if you have a strong Internet presence, which includes having solid, up-to-date resume, Github, LinkedIn, personal site, and Google search presence.
* Screening: [Read this](https://ideal.com/resume-screening/). A recruiter’s life is hard! Sometimes, this involves the recruiter calling you to ask you basic questions about Linux or Java, or sending you a quiz. Depending on the company, a majority of candidates are filtered out here.
* Phone Interviews: The recruiter will ask you to schedule time for 2-3 interviews, which are usually coding-style interviews that are designed to extract signal regarding how strong your problem-solving skills are and how you respond to scenarios/questions you’ve never seen before. They’ll schedule one at a time and more if they need stronger signal from you. Depending on the company, over half of candidates are filtered out here.
* Offer: If most of your interviewers returned with a strong signal for “hire”, you’re likely to receive an offer! Depending on the company, over half of candidates accept their offer. Exceptions include Google, because you can get an offer but still need to be host-matched to a team, and most positions on different teams may already be filled up depending on how late you apply.
* Hire: You’ve been hired! Don’t renege on offers you’ve signed: this is how you burn bridges or get blacklisted, and word travels fast in recruiting communities (which are cross-company).


## Getting tech internships
Look to use every summer you have to get as much work experience as possible and figure out what you like and don’t like. Don’t take unpaid internships. Start applying to companies in August, since that’s when companies start their hiring processes for next summer’s interns. It’s still okay to start applying as late as January. Your connections with upperclassmen and alumni will net you referrals, which usually skips you past the “screening” phase of hiring pipelines and straight into the “interview” phase. Be responsive and keep good communications with your recruiters. If you have to schedule interviews with 3 companies, try to schedule them on the same 1-2 weeks so you’ll be in “interview mode” the whole time, which is when your interview skills are super sharp since you’ve hopefully been studying and mock interviewing with your peers for weeks. If you have an outstanding offer from company X and still need to interview at company Y, ask X for an extension and ask Y to expedite their process, citing offer X (WARNING: this does not apply to [Google EngRes](https://www.google.com/about/careers/students/engres.html) - if they hear of offer X, they will stop interviewing you).

Job Application Season™ is stressful. It’s like a part-time job while you’re juggling your academics and extracurriculars, so plan your schedules and involvements accordingly prior to Fall semester. But, like other things, you can and will succeed when you pour time and energy into it, leverage your support network, and get help from the right people. If you’re a freshman or sophomore, don’t worry too much - you’ll get there, and junior year internships are the most important ones anyway.


## Resources to ace your interviews
First, read this [introductory guide](https://triplebyte.com/blog/how-to-pass-a-programming-interview) from TripleByte.

Next, read through my [systematic interviewing process](https://pastebin.com/d0rJp2G6). Good candidates can run through 2-3 questions per 45-minute interview session following some version of the above process. I would ask peers and alumni to mock interview me and practice this step-by-step until it was totally ingrained into the way I did interviews.

I recommend doing interviews in Python, since you can do more stuff faster and be less caught up in the syntax. But pick whatever language you like and stick to it. You should be grinding Leetcode easy/medium questions for the whole month before your interviews to maximize how many patterns you’ll recognize during the real thing.

Here’s a [comprehensive list](https://docs.google.com/document/d/1qedA6n91sEzQ6QhVunt-0y2DgrhOUpgetGmgnGO8v1o/edit?usp=sharing) of my study resources and favorite questions for coding and systems. Also included is a giant list of the most relevant Leetcode questions. Go crazy.


## Managing internships and getting return offers
So you signed an offer! Congrats! Now what? First off, you’re not off the hook, you should continue learning things, but take time to celebrate, you king/queen. The company will walk you through things like residency, onboarding, etc. Once you start your internship, you’ll likely do an intern project and connect with other interns. Figure out what work-life balance you’re comfortable with. To maximize your chance at a return offer, finish your project earlier than the deadline, be proactive about work beyond the initial scope of your project, and push your diffs/PRs/CLs/contributions regularly and consistently. Actively seek feedback from other people on your team, not just your direct manager. If you feel like you’re not being challenged and have the capacity to do more, ask for more tasks to chew on. Above all, mesh with the company culture - one of the biggest things they’ll ask your manager is “Would you be happy to work with this intern on a different team in the future?”

That said, if you’re having a bad experience, make it known. If your intern manager is making you feel uncomfortable or overly stressed in any way, escalate it to his/her manager and HR - good companies will have zero-tolerance policies.


## Get exposure to stuff outside of class
Top tier companies hire people who shine in and out of academics, and your courses by themselves won’t teach you most things relevant in industry today. Although they’ll give you a great foundation, undergraduate studies are a pipeline for future graduate researchers. If you just want a job, then focus on things outside of class. As V said, your professors haven’t coded in decades, since academia rewards very different skills and traits than industry.

Go to career fairs and shoot your shot with companies. If you’re a woman in CS, look for scholarships and go to conferences like Grace Hopper that are designed to empower minorities in tech. Go to as [many hackathons](https://mlh.io/seasons/na-2020/events) as you’re comfortable with, since hackathons are basically a special kind of career fair. Go to USACS’ Hacker Hours or similar workshop-like events, stay after and learn more from regulars and upperclassmen. This sounds like a lot, because it is, so I will re-emphasize a previous point: find a mentor to help guide you through this! It’s as easy as joining a mentorship program, or better yet do what I did: go up to someone who seems smart and nice, and say “hey would you be willing to be my mentor and teach me stuff?” - it works.


## Explore positions besides Software Engineer
I’m a [Production Engineer](https://engineering.fb.com/category/production-engineering/) at FB and the work is much more interesting to me than standard SWE work since it involves fixing things that break in production, debugging complex systems, and improving security and reliability. A few months into my job and I’ve broken and fixed FB a few times already. Tech is very interdisciplinary; I’m sure if you’re passionate about X, you can find something that pays well and is a cross between X and tech. Talk to your mentors about this, and follow relevant newsletters:
* [USACS](http://usacs.rutgers.edu/)
* [Princeton e-club](https://www.princetoneclub.com/#About-Section)
* [tech:NYC](https://www.technyc.org/newsletter)
* [Startup Digests](https://www.startupdigest.com/digests)
* [YCombinator](https://www.ycombinator.com/subscribe/)
* [VC Newsletters](https://medium.com/@etiennebr/my-top-9-newsletters-if-you-want-to-be-up-to-date-on-the-vc-technology-industry-e195c74a72a2)


## Engage yourself in communities outside of Rutgers
I shouldn’t have to explain why this is important to your own personal growth. Here are some ideas:
* Make a [Github](https://github.com/join) and build your own website as a first step. You can do this at a hackathon. It’s like creating your own place on the Internet, and you decide what it is, a blog, a resume/marketing thing, etc. It’s a good way to start putting yourself out there.
* Get engaged with [civic hacking](https://opengovdata.io/2014/civic-hacking/) since tech can be used for a ton of social good! For example, in my hackNY summer, we worked with the Human Trafficking Response Unit of NYC to build systems to help their analysts track down traffickers.
* Apply to fellowships like [hackNY](https://apply.hackny.org) and work on building your network of like-minded friends. I love this community and everyone in it.


## Follow Sam Altman’s Startup Class and other university lecture series
Watch the lectures at https://startupclass.samaltman.com/. I did this in freshman year and even though I didn’t end up making a startup, I learned a ton of lessons about the industry from the prolific speakers who deliver these lectures, all of them successful startup founders themselves in YC’s [portfolio](https://www.ycombinator.com/topcompanies/). Here’s all the [notes](https://docs.google.com/document/d/1ljUeGxoKgTyP4-4vfWgNiFNMyyE8W8q9Ky139NVuSpQ/edit) I took (warning: old).

Also, follow other university lecture series, like [MIT’s OpenCourseWare](https://ocw.mit.edu/index.htm) or [Harvard’s CS50](https://online-learning.harvard.edu/course/cs50-introduction-computer-science).


## Build projects as a supplement
Turn your ability to compartmentalize and keep a tight schedule into habits. Having these habits will help you find time to explore your own curiosities by building projects. Some of my favorite college memories involve making crazy stuff with strangers at hackathons halfway down the coast, and student orgs will organize buses or carpools to and from these kinds of events. But keep in mind this isn’t a replacement for good grades; you should already have a good academic record as a foundation before you think about extra stuff like this.

## Systematic Interview Process
1. Ask intelligent clarifying questions: for *this* input, do I get *this* output? Your goal should be to really understand the problem.

2. Build your set of 2-3 *comprehensive* test cases. Consider edge cases out loud and how to handle them. Write the cases out so you don't forget.

3. Now that you know your program's desired behavior, sketch out 2-4 algorithms to solve the problem. 
  a. Always start with the dumbest brute-force algorithm and gradually improve on it by recognizing places you're wasting computation.
  b. Brainstorm things you know like dynamic programming, visualizing the problem as a graph/tree, etc.
  c. In the worst case, you have 1 dumb, brute-force algorithm that you can technically implement.

4. For each of your 2-4 algorithms, list next to them their expected time and space complexities. Optionally, note their simplicity/readability as well.
Example:
			    Time		  Space		  Simple?
Algo 1:		O(n^2)		O(1)		  yes
Algo 2:		O(n)		  O(n)		  maybe
Algo 3: 	O(log n)	O(n^2)		eh?

5. Compare and contrast the algorithms out loud, taking into consideration all of the parameters you've laid out. Other things to note are code length, time limitations, system capabilities (what's the I/O bandwidth?), and your own ability/confidence in writing out the solutions in full. Only commit to one approach after consulting your interviewer for their preference (if they have any).

6. Important: sketch out exactly how exactly you're going to implement your chosen solution. Anticipate what methods you're going to need, their signatures, runtimes and input/outputs. This is better than getting deep into your solution and realizing that one code segment is better off being modularized for cleanliness/usability, or realizing that another solution is better entirely.
Example: Given a binary tree, print out all paths that sum to a given target value.
You might think to use BFS here, but DFS is better because then you can just print out the values of the nodes when your recursion propagates back ui rather than keeping auxiliary data structures to track your paths.

7. Start implementing your solution in code. Don't make them ask you to do this. This should be ~5 minutes into the interview now.
If one segment of code is going to take a significant chunk of time and isn't part of your main algorithm, offload it to another method, assume it'll work and tell interviewer you'll implement it later if you have time, then continue. Your main algorithm is the main priority.

8. If you get to this point, immediately run your algorithm on 1-2 of your test cases. There's no need to run line-by-line, just make sure it works - it's great if you catch your own mistakes here, so that the interviewer sees that you're self-righting.

9. Ideally by this point, your code is clean, modularized and ready-to-run. But if it's not, scan it now for readability, runtime, etc. and speak your thoughts.

10. The interviewer should be satisfied now and will probably take a picture of your work.
